<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¿«ä¹å°ä¸¥è…°ç—›å¤„æ–¹ç”Ÿæˆå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // è®¾ç½®PDF.js workerè·¯å¾„ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .select-all {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .select-all button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .select-all button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .generate-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        .generate-btn:active {
            transform: translateY(0);
        }

        .generate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .image-item {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            padding: 15px;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .image-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border-color: #667eea;
        }

        .image-item.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .image-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            overflow: hidden;
            border-radius: 10px;
            background: #f5f5f5;
        }

        .image-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s;
        }

        .image-item:hover .image-wrapper img {
            transform: scale(1.1);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-wrapper input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .count-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
            padding: 5px 10px;
            border-radius: 8px;
        }

        .count-control button {
            width: 30px;
            height: 30px;
            border: none;
            background: #667eea;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .count-control button:hover {
            background: #5568d3;
            transform: scale(1.1);
        }

        .count-control button:active {
            transform: scale(0.95);
        }

        .count-control button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .count-control input {
            width: 50px;
            text-align: center;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            padding: 5px;
            font-size: 16px;
            font-weight: bold;
        }

        .count-control input:focus {
            outline: none;
            border-color: #667eea;
        }

        .image-label {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
            font-size: 18px;
        }

        .loading.show {
            display: block;
        }

        .preview-container {
            display: none;
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .preview-container.show {
            display: block;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .preview-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }

        .preview-actions {
            display: flex;
            gap: 10px;
        }

        .preview-actions button {
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .preview-btn {
            background: #28a745;
            color: white;
        }

        .preview-btn:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .close-preview-btn {
            background: #dc3545;
            color: white;
        }

        .close-preview-btn:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .preview-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            min-height: 600px;
            max-height: 800px;
            overflow: auto;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .preview-content canvas {
            display: block;
            margin: 0 auto 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 5px;
        }

        .preview-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }

        .preview-nav button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .preview-nav button:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .preview-nav button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .page-info {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .image-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 15px;
            }

            .controls {
                flex-direction: column;
                gap: 15px;
            }

            h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ–¼ï¸ å¿«ä¹å°ä¸¥è…°ç—›å¤„æ–¹ç”Ÿæˆå™¨</h1>
        
        <div class="controls">
            <div class="select-all">
                <button onclick="selectAll()">å…¨é€‰</button>
                <button onclick="deselectAll()">å…¨ä¸é€‰</button>
            </div>
            <button class="generate-btn" onclick="generatePDF()">ç”ŸæˆPDF</button>
        </div>

        <div class="loading" id="loading">æ­£åœ¨ç”ŸæˆPDFï¼Œè¯·ç¨å€™...</div>

        <div class="preview-container" id="previewContainer">
            <div class="preview-header">
                <div class="preview-title">ğŸ“„ PDFé¢„è§ˆ</div>
                <div class="preview-actions">
                    <button class="preview-btn" onclick="downloadPDF()">ä¸‹è½½PDF</button>
                    <button class="close-preview-btn" onclick="closePreview()">å…³é—­é¢„è§ˆ</button>
                </div>
            </div>
            <div class="preview-content" id="previewContent">
                <div class="preview-nav">
                    <button onclick="previousPage()" id="prevBtn">ä¸Šä¸€é¡µ</button>
                    <span class="page-info" id="pageInfo">ç¬¬ 1 é¡µï¼Œå…± 1 é¡µ</span>
                    <button onclick="nextPage()" id="nextBtn">ä¸‹ä¸€é¡µ</button>
                </div>
            </div>
        </div>

        <div class="image-grid" id="imageGrid"></div>
    </div>

    <script>
        const { jsPDF } = window.jspdf;
        const imageData = [];
        const totalImages = 50;
        let currentPDFBlob = null;
        let currentPDFDoc = null;
        let currentPageNum = 1;
        let totalPages = 0;

        // åˆå§‹åŒ–å›¾ç‰‡æ•°æ®
        for (let i = 1; i <= totalImages; i++) {
            imageData.push({
                id: i,
                selected: false,
                count: 5,
                thumbPath: `pic/${i}.jpg`,
                detailPath: `pic_detail/${i}.jpg`
            });
        }

        // æ¸²æŸ“å›¾ç‰‡ç½‘æ ¼
        function renderGrid() {
            const grid = document.getElementById('imageGrid');
            grid.innerHTML = '';

            imageData.forEach(item => {
                const imageItem = document.createElement('div');
                imageItem.className = `image-item ${item.selected ? 'selected' : ''}`;
                
                imageItem.innerHTML = `
                    <div class="image-wrapper">
                        <img src="${item.thumbPath}" alt="å›¾ç‰‡ ${item.id}" loading="lazy">
                    </div>
                    <div class="checkbox-wrapper">
                        <input type="checkbox" 
                               ${item.selected ? 'checked' : ''} 
                               onchange="toggleSelect(${item.id})">
                        <span class="image-label">å›¾ç‰‡ ${item.id}</span>
                    </div>
                    <div class="count-control">
                        <button onclick="decreaseCount(${item.id})" 
                                ${item.count <= 1 ? 'disabled' : ''}>âˆ’</button>
                        <input type="number" 
                               value="${item.count}" 
                               min="1" 
                               onchange="updateCount(${item.id}, this.value)"
                               oninput="validateCount(${item.id}, this)">
                        <button onclick="increaseCount(${item.id})">+</button>
                    </div>
                `;
                
                grid.appendChild(imageItem);
            });
        }

        // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
        function toggleSelect(id) {
            const item = imageData.find(img => img.id === id);
            if (item) {
                item.selected = !item.selected;
                renderGrid();
            }
        }

        // å¢åŠ æ¬¡æ•°
        function increaseCount(id) {
            const item = imageData.find(img => img.id === id);
            if (item) {
                item.count++;
                // è°ƒæ•´æ¬¡æ•°æ—¶è‡ªåŠ¨é€‰ä¸­
                if (!item.selected) {
                    item.selected = true;
                }
                renderGrid();
            }
        }

        // å‡å°‘æ¬¡æ•°
        function decreaseCount(id) {
            const item = imageData.find(img => img.id === id);
            if (item && item.count > 1) {
                item.count--;
                // è°ƒæ•´æ¬¡æ•°æ—¶è‡ªåŠ¨é€‰ä¸­
                if (!item.selected) {
                    item.selected = true;
                }
                renderGrid();
            }
        }

        // æ›´æ–°æ¬¡æ•°
        function updateCount(id, value) {
            const item = imageData.find(img => img.id === id);
            if (item) {
                const numValue = parseInt(value);
                if (!isNaN(numValue) && numValue >= 1) {
                    item.count = numValue;
                } else {
                    item.count = 1;
                }
                // è°ƒæ•´æ¬¡æ•°æ—¶è‡ªåŠ¨é€‰ä¸­
                if (!item.selected) {
                    item.selected = true;
                }
                renderGrid();
            }
        }

        // éªŒè¯æ¬¡æ•°è¾“å…¥
        function validateCount(id, input) {
            const value = parseInt(input.value);
            if (isNaN(value) || value < 1) {
                input.value = 1;
            }
        }

        // å…¨é€‰
        function selectAll() {
            imageData.forEach(item => item.selected = true);
            renderGrid();
        }

        // å…¨ä¸é€‰
        function deselectAll() {
            imageData.forEach(item => item.selected = false);
            renderGrid();
        }

        // åŠ è½½å›¾ç‰‡ä¸ºBase64ï¼ˆä¿®å¤Canvasæ±¡æŸ“é—®é¢˜ï¼‰
        function loadImageAsBase64(url) {
            return new Promise(async (resolve, reject) => {
                const errorInfo = { url, method: '', error: null };
                
                try {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯file://åè®®
                    const isFileProtocol = window.location.protocol === 'file:';
                    if (isFileProtocol) {
                        console.warn('âš ï¸ æ£€æµ‹åˆ°file://åè®®ï¼');
                        console.warn('âš ï¸ file://åè®®ä¸‹ï¼Œfetchå’ŒXMLHttpRequestéƒ½æ— æ³•åŠ è½½æœ¬åœ°æ–‡ä»¶ï¼');
                        console.warn('âš ï¸ å¿…é¡»ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œï¼');
                        console.warn('è§£å†³æ–¹æ¡ˆï¼š');
                        console.warn('  1. æ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥é¡¹ç›®ç›®å½•');
                        console.warn('  2. è¿è¡Œ: python -m http.server 8000');
                        console.warn('  3. è®¿é—®: http://localhost:8000');
                        errorInfo.method = 'file://åè®®æ£€æµ‹';
                        errorInfo.isFileProtocol = true;
                    }
                    
                    // æ–¹æ³•1: ä¼˜å…ˆä½¿ç”¨fetch + FileReaderï¼ˆå®Œå…¨é¿å…Canvasæ±¡æŸ“é—®é¢˜ï¼‰
                    try {
                        errorInfo.method = 'fetch + FileReaderæ–¹æ³•';
                        const response = await fetch(url);
                        if (response.ok) {
                            const blob = await response.blob();
                            
                            // æ£€æŸ¥blobç±»å‹
                            if (!blob.type.startsWith('image/')) {
                                throw new Error(`ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶ï¼Œç±»å‹: ${blob.type}`);
                            }
                            
                            // ç›´æ¥ä½¿ç”¨FileReaderè½¬æ¢ä¸ºbase64ï¼Œå®Œå…¨ä¸ç»è¿‡Canvas
                            const reader = new FileReader();
                            reader.onloadend = function() {
                                if (reader.readyState === FileReader.DONE) {
                                    const base64Data = reader.result;
                                    if (base64Data && base64Data.startsWith('data:image/')) {
                                        // ç›´æ¥è¿”å›base64ï¼Œä¸ç»è¿‡ä»»ä½•Canvasæ“ä½œ
                                        console.log(`âœ“ å›¾ç‰‡åŠ è½½æˆåŠŸ (fetch+FileReader): ${url}`);
                                        resolve(base64Data);
                                    } else {
                                        errorInfo.error = 'FileReaderè¿”å›çš„æ•°æ®æ ¼å¼æ— æ•ˆ';
                                        console.error(`âœ— FileReaderæ•°æ®æ ¼å¼æ— æ•ˆ: ${url}`);
                                        tryMethod2();
                                    }
                                } else {
                                    errorInfo.error = 'FileReaderè¯»å–æœªå®Œæˆ';
                                    console.error(`âœ— FileReaderè¯»å–æœªå®Œæˆ: ${url}`);
                                    tryMethod2();
                                }
                            };
                            reader.onerror = function(e) {
                                errorInfo.error = 'FileReaderè¯»å–å¤±è´¥';
                                console.error(`âœ— FileReaderå¤±è´¥: ${url}`, e);
                                tryMethod2();
                            };
                            reader.readAsDataURL(blob);
                            return; // é‡è¦ï¼šç›´æ¥è¿”å›ï¼Œä¸ç»§ç»­æ‰§è¡Œåé¢çš„ä»£ç 
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    } catch (fetchError) {
                        // fetchå¤±è´¥ï¼Œå°è¯•æ–¹æ³•2
                        errorInfo.error = fetchError.message || fetchError;
                        console.log(`Fetchæ–¹æ³•å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æ–¹æ³•: ${url}`, fetchError);
                    }
                    
                    // æ–¹æ³•2: å¦‚æœfetchå¤±è´¥ï¼Œä½¿ç”¨XMLHttpRequestï¼ˆé€‚ç”¨äºfile://åè®®ï¼‰
                    function tryMethod2() {
                        errorInfo.method = 'XMLHttpRequestæ–¹æ³•ï¼ˆå¤‡ç”¨ï¼‰';
                        
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', url, true);
                        xhr.responseType = 'blob';
                        
                        xhr.onload = function() {
                            if (xhr.status === 200 || xhr.status === 0) { // 0è¡¨ç¤ºfile://åè®®æˆåŠŸ
                                const blob = xhr.response;
                                
                                // ä½¿ç”¨FileReaderè½¬æ¢ä¸ºbase64
                                const reader = new FileReader();
                                reader.onloadend = function() {
                                    if (reader.readyState === FileReader.DONE) {
                                        const base64Data = reader.result;
                                        if (base64Data && base64Data.startsWith('data:image/')) {
                                            console.log(`âœ“ å›¾ç‰‡åŠ è½½æˆåŠŸ (XMLHttpRequest): ${url}`);
                                            resolve(base64Data);
                                        } else {
                                            errorInfo.error = 'FileReaderè¿”å›çš„æ•°æ®æ ¼å¼æ— æ•ˆ';
                                            console.error(`âœ— FileReaderæ•°æ®æ ¼å¼æ— æ•ˆ: ${url}`);
                                            tryMethod3();
                                        }
                                    } else {
                                        errorInfo.error = 'FileReaderè¯»å–æœªå®Œæˆ';
                                        console.error(`âœ— FileReaderè¯»å–æœªå®Œæˆ: ${url}`);
                                        tryMethod3();
                                    }
                                };
                                reader.onerror = function(e) {
                                    errorInfo.error = 'FileReaderè¯»å–å¤±è´¥';
                                    console.error(`âœ— FileReaderå¤±è´¥: ${url}`, e);
                                    tryMethod3();
                                };
                                reader.readAsDataURL(blob);
                            } else {
                                errorInfo.error = `HTTP ${xhr.status}`;
                                console.error(`âœ— XMLHttpRequestå¤±è´¥: ${url} (çŠ¶æ€ç : ${xhr.status})`);
                                tryMethod3();
                            }
                        };
                        
                        xhr.onerror = function(e) {
                            errorInfo.error = 'XMLHttpRequestè¯·æ±‚å¤±è´¥';
                            if (isFileProtocol) {
                                errorInfo.error = 'XMLHttpRequeståœ¨file://åè®®ä¸‹æ— æ³•å·¥ä½œï¼Œå¿…é¡»ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨';
                            }
                            console.error(`âœ— XMLHttpRequesté”™è¯¯: ${url}`, e);
                            console.error(`  çŠ¶æ€: ${xhr.status}, çŠ¶æ€æ–‡æœ¬: ${xhr.statusText}`);
                            tryMethod3();
                        };
                        
                        xhr.ontimeout = function() {
                            errorInfo.error = 'XMLHttpRequestè¶…æ—¶';
                            console.error(`âœ— XMLHttpRequestè¶…æ—¶: ${url}`);
                            tryMethod3();
                        };
                        
                        xhr.timeout = 10000; // 10ç§’è¶…æ—¶
                        xhr.send();
                    }
                    
                    // æ–¹æ³•3: æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆ - å†æ¬¡å°è¯•XMLHttpRequestï¼ˆä½¿ç”¨ä¸åŒçš„responseTypeï¼‰
                    function tryMethod3() {
                        // å¦‚æœæ˜¯file://åè®®ï¼Œç›´æ¥è¿”å›å ä½å›¾ï¼Œå› ä¸ºæ‰€æœ‰æ–¹æ³•éƒ½ä¼šå¤±è´¥
                        if (isFileProtocol) {
                            errorInfo.error = 'file://åè®®ä¸‹æ— æ³•åŠ è½½æœ¬åœ°æ–‡ä»¶ã€‚å¿…é¡»ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œï¼';
                            errorInfo.method = 'file://åè®®é™åˆ¶';
                            console.error('âŒ æ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥ï¼šfile://åè®®çš„å®‰å…¨é™åˆ¶');
                            console.error('âœ… è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œ');
                            console.error('  1. æ‰“å¼€å‘½ä»¤è¡Œï¼Œcdåˆ°é¡¹ç›®ç›®å½•');
                            console.error('  2. è¿è¡Œ: python -m http.server 8000');
                            console.error('  3. è®¿é—®: http://localhost:8000');
                            resolve(createPlaceholderImage(800, 600, url, errorInfo));
                            return;
                        }
                        
                        errorInfo.method = 'XMLHttpRequestæ–¹æ³•ï¼ˆarraybufferå¤‡ç”¨ï¼‰';
                        
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', url, true);
                        xhr.responseType = 'arraybuffer'; // ä½¿ç”¨arraybufferè€Œä¸æ˜¯blob
                        
                        xhr.onload = function() {
                            if (xhr.status === 200 || xhr.status === 0) {
                                try {
                                    const arrayBuffer = xhr.response;
                                    if (!arrayBuffer || arrayBuffer.byteLength === 0) {
                                        throw new Error('ArrayBufferä¸ºç©º');
                                    }
                                    
                                    // å°†ArrayBufferè½¬æ¢ä¸ºBlobï¼Œç„¶åè½¬æ¢ä¸ºbase64
                                    const blob = new Blob([arrayBuffer]);
                                    const reader = new FileReader();
                                    
                                    reader.onloadend = function() {
                                        if (reader.readyState === FileReader.DONE) {
                                            const base64Data = reader.result;
                                            if (base64Data && base64Data.startsWith('data:image/')) {
                                                console.log(`âœ“ å›¾ç‰‡åŠ è½½æˆåŠŸ (XMLHttpRequest+ArrayBuffer): ${url}`);
                                                resolve(base64Data);
                                            } else {
                                                errorInfo.error = 'FileReaderè¿”å›çš„æ•°æ®æ ¼å¼æ— æ•ˆ';
                                                console.error(`âœ— FileReaderæ•°æ®æ ¼å¼æ— æ•ˆ: ${url}`);
                                                resolve(createPlaceholderImage(800, 600, url, errorInfo));
                                            }
                                        } else {
                                            errorInfo.error = 'FileReaderè¯»å–æœªå®Œæˆ';
                                            console.error(`âœ— FileReaderè¯»å–æœªå®Œæˆ: ${url}`);
                                            resolve(createPlaceholderImage(800, 600, url, errorInfo));
                                        }
                                    };
                                    
                                    reader.onerror = function(e) {
                                        errorInfo.error = 'FileReaderè¯»å–å¤±è´¥';
                                        console.error(`âœ— FileReaderå¤±è´¥: ${url}`, e);
                                        resolve(createPlaceholderImage(800, 600, url, errorInfo));
                                    };
                                    
                                    reader.readAsDataURL(blob);
                                } catch (e) {
                                    errorInfo.error = `ArrayBufferå¤„ç†å¤±è´¥: ${e.message}`;
                                    console.error(`âœ— ArrayBufferå¤„ç†å¤±è´¥: ${url}`, e);
                                    resolve(createPlaceholderImage(800, 600, url, errorInfo));
                                }
                            } else {
                                errorInfo.error = `HTTP ${xhr.status}`;
                                console.error(`âœ— XMLHttpRequestå¤±è´¥: ${url} (çŠ¶æ€ç : ${xhr.status})`);
                                resolve(createPlaceholderImage(800, 600, url, errorInfo));
                            }
                        };
                        
                        xhr.onerror = function(e) {
                            errorInfo.error = 'XMLHttpRequestè¯·æ±‚å¤±è´¥';
                            if (isFileProtocol) {
                                errorInfo.error = 'æ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥ï¼šfile://åè®®ä¸‹æ— æ³•åŠ è½½æœ¬åœ°æ–‡ä»¶ã€‚å¿…é¡»ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œï¼';
                                console.error('âŒ æ‰€æœ‰åŠ è½½æ–¹æ³•éƒ½å¤±è´¥äº†ï¼');
                                console.error('âŒ åŸå› ï¼šfile://åè®®çš„å®‰å…¨é™åˆ¶');
                                console.error('âœ… è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œ');
                                console.error('  1. æ‰“å¼€å‘½ä»¤è¡Œï¼Œcdåˆ°é¡¹ç›®ç›®å½•');
                                console.error('  2. è¿è¡Œ: python -m http.server 8000');
                                console.error('  3. è®¿é—®: http://localhost:8000');
                            }
                            console.error(`âœ— XMLHttpRequesté”™è¯¯: ${url}`, e);
                            console.error(`  çŠ¶æ€: ${xhr.status}, çŠ¶æ€æ–‡æœ¬: ${xhr.statusText}`);
                            resolve(createPlaceholderImage(800, 600, url, errorInfo));
                        };
                        
                        xhr.ontimeout = function() {
                            errorInfo.error = 'XMLHttpRequestè¶…æ—¶';
                            console.error(`âœ— XMLHttpRequestè¶…æ—¶: ${url}`);
                            resolve(createPlaceholderImage(800, 600, url, errorInfo));
                        };
                        
                        xhr.timeout = 10000;
                        xhr.send();
                    }
                    
                    // å¦‚æœæ–¹æ³•1å¤±è´¥ï¼Œå°è¯•æ–¹æ³•2
                    tryMethod2();
                    
                } catch (error) {
                    errorInfo.error = error.message || error;
                    console.error(`âœ— åŠ è½½å›¾ç‰‡æ—¶å‘ç”Ÿé”™è¯¯: ${url}`, error);
                    resolve(createPlaceholderImage(800, 600, url, errorInfo));
                }
            });
        }
        
        // åˆ›å»ºå ä½å›¾ç‰‡
        function createPlaceholderImage(width, height, url = '', errorInfo = null) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // ç»˜åˆ¶ç°è‰²èƒŒæ™¯
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, width, height);
            
            // ç»˜åˆ¶è¾¹æ¡†
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, width, height);
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = '#999999';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('å›¾ç‰‡åŠ è½½å¤±è´¥', width / 2, height / 2 - 30);
            
            // å¦‚æœæœ‰é”™è¯¯ä¿¡æ¯ï¼Œæ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
            if (errorInfo && errorInfo.error) {
                ctx.fillStyle = '#666666';
                ctx.font = '14px Arial';
                ctx.fillText(`é”™è¯¯: ${errorInfo.error}`, width / 2, height / 2);
                
                if (url) {
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#888888';
                    const maxWidth = width - 40;
                    const text = url.length > 50 ? '...' + url.slice(-47) : url;
                    ctx.fillText(text, width / 2, height / 2 + 20);
                }
            }
            
            return canvas.toDataURL('image/png');
        }

        // å°†ä¸­æ–‡æ–‡å­—æ¸²æŸ“ä¸ºå›¾ç‰‡ï¼ˆè§£å†³PDFä¸­æ–‡ä¹±ç é—®é¢˜ï¼‰
        function renderTextAsImage(text, fontSize, textColor, maxWidthMM) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®å­—ä½“
            const fontFamily = "'Microsoft YaHei', 'SimHei', Arial, sans-serif";
            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = textColor || '#000000';
            
            // æµ‹é‡æ–‡å­—å®½åº¦ï¼ˆåƒç´ ï¼‰
            const metrics = ctx.measureText(text);
            const textWidth = metrics.width;
            const textHeight = fontSize * 1.3;
            
            // è®¡ç®—canvaså°ºå¯¸
            // å¦‚æœæŒ‡å®šäº†æœ€å¤§å®½åº¦ï¼ˆæ¯«ç±³ï¼‰ï¼Œè½¬æ¢ä¸ºåƒç´ 
            let canvasWidth = textWidth + 40; // å·¦å³å„ç•™20pxè¾¹è·
            if (maxWidthMM) {
                const maxWidthPx = maxWidthMM * 3.779527559; // æ¯«ç±³è½¬åƒç´ 
                canvasWidth = Math.min(canvasWidth, maxWidthPx);
            }
            
            canvas.width = canvasWidth;
            canvas.height = textHeight + 20; // ä¸Šä¸‹å„ç•™10pxè¾¹è·
            
            // é‡æ–°è®¾ç½®å­—ä½“å’Œæ ·å¼ï¼ˆcanvaså°ºå¯¸æ”¹å˜åä¼šé‡ç½®ï¼‰
            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = textColor || '#000000';
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            return canvas.toDataURL('image/png');
        }

        // ç”ŸæˆPDF
        async function generatePDF() {
            const selectedImages = imageData.filter(img => img.selected);
            
            if (selectedImages.length === 0) {
                alert('è¯·è‡³å°‘é€‰æ‹©ä¸€å¼ å›¾ç‰‡ï¼');
                return;
            }

            const loading = document.getElementById('loading');
            const generateBtn = document.querySelector('.generate-btn');
            loading.classList.add('show');
            generateBtn.disabled = true;

            try {
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: 'a4'
                });

                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const margin = 10;
                const contentWidth = pageWidth - 2 * margin;
                const contentHeight = pageHeight - 2 * margin - 20; // ç•™å‡ºæ–‡å­—ç©ºé—´

                const failedImages = []; // è®°å½•åŠ è½½å¤±è´¥çš„å›¾ç‰‡

                for (let i = 0; i < selectedImages.length; i++) {
                    const item = selectedImages[i];
                    
                    if (i > 0) {
                        pdf.addPage();
                    }

                    try {
                        // åŠ è½½è¯¦ç»†å›¾ç‰‡
                        const imgData = await loadImageAsBase64(item.detailPath);
                        
                        // è®¡ç®—å›¾ç‰‡å°ºå¯¸ï¼Œä¿æŒå®½é«˜æ¯”
                        const img = new Image();
                        img.src = imgData;
                        await new Promise((resolve) => {
                            img.onload = resolve;
                        });

                        const imgAspectRatio = img.width / img.height;
                        let imgWidth = contentWidth;
                        let imgHeight = contentWidth / imgAspectRatio;

                        if (imgHeight > contentHeight) {
                            imgHeight = contentHeight;
                            imgWidth = contentHeight * imgAspectRatio;
                        }

                        const x = (pageWidth - imgWidth) / 2;
                        const y = margin + 10;

                        // æ·»åŠ å›¾ç‰‡
                        pdf.addImage(imgData, 'JPEG', x, y, imgWidth, imgHeight);

                        // æ·»åŠ æ¬¡æ•°æ ‡æ³¨ï¼ˆä½¿ç”¨å›¾ç‰‡æ–¹å¼æ¸²æŸ“ä¸­æ–‡ï¼Œé¿å…ä¹±ç ï¼‰
                        const textY = y + imgHeight + 15;
                        const labelText = `å›¾ç‰‡ ${item.id} Ã— ${item.count}`;
                        const textImage = renderTextAsImage(labelText, 16, '#667eea', contentWidth);
                        const textImg = new Image();
                        textImg.src = textImage;
                        await new Promise((resolve) => {
                            textImg.onload = resolve;
                        });
                        const textImgWidth = textImg.width * 0.264583; // åƒç´ è½¬æ¯«ç±³
                        const textImgHeight = textImg.height * 0.264583;
                        pdf.addImage(textImage, 'PNG', (pageWidth - textImgWidth) / 2, textY - textImgHeight / 2, textImgWidth, textImgHeight);

                    } catch (error) {
                        console.error(`åŠ è½½å›¾ç‰‡ ${item.id} å¤±è´¥:`, error);
                        failedImages.push(item.id);
                        
                        // å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œæ·»åŠ æ–‡å­—è¯´æ˜ï¼ˆä½¿ç”¨å›¾ç‰‡æ–¹å¼æ¸²æŸ“ä¸­æ–‡ï¼‰
                        const errorText1 = `å›¾ç‰‡ ${item.id} åŠ è½½å¤±è´¥`;
                        const errorText2 = `æ¬¡æ•°: ${item.count}`;
                        const errorText3 = `è¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨: ${item.detailPath}`;
                        const errorImage1 = renderTextAsImage(errorText1, 14, '#c80000', contentWidth);
                        const errorImage2 = renderTextAsImage(errorText2, 14, '#c80000', contentWidth);
                        const errorImage3 = renderTextAsImage(errorText3, 12, '#999999', contentWidth);
                        
                        const errorImg1 = new Image();
                        errorImg1.src = errorImage1;
                        await new Promise((resolve) => {
                            errorImg1.onload = resolve;
                        });
                        const errorImg2 = new Image();
                        errorImg2.src = errorImage2;
                        await new Promise((resolve) => {
                            errorImg2.onload = resolve;
                        });
                        const errorImg3 = new Image();
                        errorImg3.src = errorImage3;
                        await new Promise((resolve) => {
                            errorImg3.onload = resolve;
                        });
                        
                        const errorImg1Width = errorImg1.width * 0.264583;
                        const errorImg1Height = errorImg1.height * 0.264583;
                        const errorImg2Width = errorImg2.width * 0.264583;
                        const errorImg2Height = errorImg2.height * 0.264583;
                        const errorImg3Width = errorImg3.width * 0.264583;
                        const errorImg3Height = errorImg3.height * 0.264583;
                        
                        pdf.addImage(errorImage1, 'PNG', (pageWidth - errorImg1Width) / 2, pageHeight / 2 - 20, errorImg1Width, errorImg1Height);
                        pdf.addImage(errorImage2, 'PNG', (pageWidth - errorImg2Width) / 2, pageHeight / 2, errorImg2Width, errorImg2Height);
                        pdf.addImage(errorImage3, 'PNG', (pageWidth - errorImg3Width) / 2, pageHeight / 2 + 20, errorImg3Width, errorImg3Height);
                    }
                }
                
                // å¦‚æœæœ‰å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºæç¤º
                if (failedImages.length > 0) {
                    const failedMsg = `è­¦å‘Šï¼šæœ‰ ${failedImages.length} å¼ å›¾ç‰‡åŠ è½½å¤±è´¥ï¼ˆå›¾ç‰‡ç¼–å·: ${failedImages.join(', ')}ï¼‰ã€‚\n\nå¯èƒ½çš„åŸå› ï¼š\n1. å›¾ç‰‡æ–‡ä»¶ä¸å­˜åœ¨\n2. ä½¿ç”¨äº† file:// åè®®æ‰“å¼€é¡µé¢ï¼ˆè¯·ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨ï¼‰\n3. æµè§ˆå™¨è·¨åŸŸé™åˆ¶\n\nå»ºè®®ï¼šä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œï¼ˆå¦‚ï¼špython -m http.server 8000ï¼‰`;
                    console.warn(failedMsg);
                    setTimeout(() => {
                        alert(failedMsg);
                    }, 500);
                }

                // ç”ŸæˆPDF Blobç”¨äºé¢„è§ˆ
                const pdfBlob = pdf.output('blob');
                currentPDFBlob = pdfBlob;
                
                // æ˜¾ç¤ºé¢„è§ˆ
                await showPreview(pdfBlob);
                
                // åŒæ—¶è‡ªåŠ¨ä¸‹è½½PDF
                pdf.save('generated_images.pdf');
                
            } catch (error) {
                console.error('ç”ŸæˆPDFå¤±è´¥:', error);
                alert('ç”ŸæˆPDFæ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯ã€‚');
            } finally {
                loading.classList.remove('show');
                generateBtn.disabled = false;
            }
        }

        // æ˜¾ç¤ºPDFé¢„è§ˆ
        async function showPreview(pdfBlob) {
            const previewContainer = document.getElementById('previewContainer');
            const previewContent = document.getElementById('previewContent');
            
            // æ¸…é™¤ä¹‹å‰çš„é¢„è§ˆå†…å®¹
            previewContent.innerHTML = '<div class="preview-nav"><button onclick="previousPage()" id="prevBtn">ä¸Šä¸€é¡µ</button><span class="page-info" id="pageInfo">åŠ è½½ä¸­...</span><button onclick="nextPage()" id="nextBtn">ä¸‹ä¸€é¡µ</button></div>';
            
            previewContainer.classList.add('show');
            
            try {
                // ä½¿ç”¨PDF.jsåŠ è½½PDF
                const arrayBuffer = await pdfBlob.arrayBuffer();
                // PDF.js 3.x ä½¿ç”¨å…¨å±€å¯¹è±¡
                const pdfjs = window.pdfjsLib || (typeof pdfjsLib !== 'undefined' ? pdfjsLib : null);
                if (!pdfjs) {
                    throw new Error('PDF.jsæœªæ­£ç¡®åŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                }
                const loadingTask = pdfjs.getDocument({ data: arrayBuffer });
                currentPDFDoc = await loadingTask.promise;
                totalPages = currentPDFDoc.numPages;
                currentPageNum = 1;
                
                // æ¸²æŸ“ç¬¬ä¸€é¡µ
                await renderPage(1);
                
            } catch (error) {
                console.error('åŠ è½½PDFé¢„è§ˆå¤±è´¥:', error);
                previewContent.innerHTML = '<div style="text-align: center; color: red; padding: 50px;"><p>PDFé¢„è§ˆåŠ è½½å¤±è´¥ï¼Œä½†PDFæ–‡ä»¶å·²ç”Ÿæˆå¹¶ä¸‹è½½ã€‚</p><p style="font-size: 12px; margin-top: 10px;">é”™è¯¯ä¿¡æ¯: ' + (error.message || error) + '</p></div>';
            }
        }

        // æ¸²æŸ“PDFé¡µé¢
        async function renderPage(pageNum) {
            if (!currentPDFDoc) return;
            
            const previewContent = document.getElementById('previewContent');
            const page = await currentPDFDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1.5 });
            
            // åˆ›å»ºcanvas
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            
            // æ¸²æŸ“é¡µé¢
            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;
            
            // æ›´æ–°é¢„è§ˆå†…å®¹
            const navHtml = `
                <div class="preview-nav">
                    <button onclick="previousPage()" id="prevBtn" ${pageNum <= 1 ? 'disabled' : ''}>ä¸Šä¸€é¡µ</button>
                    <span class="page-info" id="pageInfo">ç¬¬ ${pageNum} é¡µï¼Œå…± ${totalPages} é¡µ</span>
                    <button onclick="nextPage()" id="nextBtn" ${pageNum >= totalPages ? 'disabled' : ''}>ä¸‹ä¸€é¡µ</button>
                </div>
            `;
            
            previewContent.innerHTML = '';
            previewContent.appendChild(canvas);
            previewContent.insertAdjacentHTML('beforeend', navHtml);
            
            // æ»šåŠ¨åˆ°é¡¶éƒ¨
            previewContent.scrollTop = 0;
        }

        // ä¸Šä¸€é¡µ
        function previousPage() {
            if (currentPageNum > 1) {
                currentPageNum--;
                renderPage(currentPageNum);
            }
        }

        // ä¸‹ä¸€é¡µ
        function nextPage() {
            if (currentPageNum < totalPages) {
                currentPageNum++;
                renderPage(currentPageNum);
            }
        }

        // å…³é—­é¢„è§ˆ
        function closePreview() {
            const previewContainer = document.getElementById('previewContainer');
            previewContainer.classList.remove('show');
            currentPDFBlob = null;
            currentPDFDoc = null;
        }

        // ä¸‹è½½PDF
        function downloadPDF() {
            if (currentPDFBlob) {
                const url = URL.createObjectURL(currentPDFBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'generated_images.pdf';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        // è¯Šæ–­å‡½æ•°ï¼šæ£€æŸ¥å›¾ç‰‡åŠ è½½ç¯å¢ƒ
        function diagnoseImageLoading() {
            const protocol = window.location.protocol;
            const hostname = window.location.hostname;
            const isFileProtocol = protocol === 'file:';
            
            console.log('=== å›¾ç‰‡åŠ è½½ç¯å¢ƒè¯Šæ–­ ===');
            console.log('åè®®:', protocol);
            console.log('ä¸»æœºå:', hostname || '(æœ¬åœ°æ–‡ä»¶)');
            console.log('å®Œæ•´URL:', window.location.href);
            
            if (isFileProtocol) {
                console.warn('âš ï¸ æ£€æµ‹åˆ°file://åè®®ï¼');
                console.warn('åŸå› ï¼šæµè§ˆå™¨å®‰å…¨é™åˆ¶ï¼Œfile://åè®®ä¸‹æ— æ³•åŠ è½½æœ¬åœ°å›¾ç‰‡æ–‡ä»¶');
                console.warn('è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œ');
                console.warn('  Python: python -m http.server 8000');
                console.warn('  Node.js: npx http-server');
                console.warn('  ç„¶åè®¿é—®: http://localhost:8000');
            } else {
                console.log('âœ“ ä½¿ç”¨HTTPåè®®ï¼Œå›¾ç‰‡åŠ è½½åº”è¯¥æ­£å¸¸');
            }
            
            // æµ‹è¯•ç¬¬ä¸€å¼ å›¾ç‰‡æ˜¯å¦å­˜åœ¨
            const testImg = new Image();
            testImg.onload = function() {
                console.log('âœ“ æµ‹è¯•å›¾ç‰‡åŠ è½½æˆåŠŸ: pic_detail/1.jpg');
            };
            testImg.onerror = function() {
                console.error('âœ— æµ‹è¯•å›¾ç‰‡åŠ è½½å¤±è´¥: pic_detail/1.jpg');
                console.error('å¯èƒ½åŸå› :');
                console.error('  1. å›¾ç‰‡æ–‡ä»¶ä¸å­˜åœ¨');
                console.error('  2. è·¯å¾„ä¸æ­£ç¡®');
                console.error('  3. æœåŠ¡å™¨é…ç½®é—®é¢˜');
            };
            testImg.src = 'pic_detail/1.jpg';
        }
        
        // åˆå§‹åŒ–
        renderGrid();
        
        // é¡µé¢åŠ è½½å®Œæˆåè¿›è¡Œè¯Šæ–­
        window.addEventListener('load', function() {
            setTimeout(diagnoseImageLoading, 500);
        });
    </script>
</body>
</html>
